#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <iomanip>
#include <random>
#include <algorithm>
#include <chrono>
#include <tuple>
#include <list>

using namespace std;

struct Studentas {
    string vardas;
    string pavarde;
    vector<int> namu_darbai;
    int egzaminas;
    double galutinis;
};

double skaiciuotiGalutini(const Studentas& studentas) {
    double nd_vidurkis = 0;
    for (int pazymys : studentas.namu_darbai) {
        nd_vidurkis += pazymys;
    }
    nd_vidurkis /= studentas.namu_darbai.size();

    return 0.4 * nd_vidurkis + 0.6 * studentas.egzaminas;
}

bool palygintiPagalVardaPavarde(const Studentas& a, const Studentas& b) {
    return std::tie(a.vardas, a.pavarde) < std::tie(b.vardas, b.pavarde);
}

bool palygintiPagalGalutini(const Studentas& a, const Studentas& b) {
    return a.galutinis > b.galutinis;
}

void sukurtiFailusPagalBalus(const vector<Studentas>& studentai, string& failo_pavadinimas, char konteineriotipas) {
    failo_pavadinimas = failo_pavadinimas.substr(0, failo_pavadinimas.find_last_of("."));
    string paliktukai_pavadinimas = failo_pavadinimas + "_paliktukai.txt";
    string pasiektukai_pavadinimas = failo_pavadinimas + "_pasiektukai.txt";

    ofstream paliktukai_failas(paliktukai_pavadinimas);
    ofstream pasiektukai_failas(pasiektukai_pavadinimas);

    if (!paliktukai_failas.is_open() || !pasiektukai_failas.is_open()) {
        cout << "Klaida atidarant failus naujiems duomenims." << endl;
        return;
    }

    vector<Studentas> pasiektukai;
    vector<Studentas> paliktukai;
    if (konteineriotipas == '1') {
        pasiektukai = vector<Studentas>();
        paliktukai = vector<Studentas>();
    }
    else {
        list<Studentas> pasiektukai;
        list<Studentas> paliktukai;
    }
    // Pasirinkimas kaip surūšiuoti
    char surusiuoti_pagal;
    cout << "Kaip norite surusiuoti rezultatus?\n"
        << "1. Pagal varda ir pavarde\n"
        << "2. Pagal galutini bala\n";
    cin >> surusiuoti_pagal;

    char strategija;
    cout << "Kokia strategija naudosite?\n"
        << "1. Mano strategija (sukuriami 2 vektoriai arba listai ir iteruojant su for loop kopijuojama i viena arba kita)\n"
        << "2. remove if\n"
        << "3. remove copy if\n";
    cin >> strategija;

    auto start_time = chrono::high_resolution_clock::now();

    if (strategija == '1') {
        for (const auto& studentas : studentai) {
            if (studentas.galutinis >= 5) {
                pasiektukai.push_back(studentas);
            }
            else {
                paliktukai.push_back(studentas);
            }
        }
    }
    else if (strategija == '2') {

        double threshold = 5;
        auto belowThreshold = [threshold](const Studentas& studentas) {
            return studentas.galutinis < threshold;
        };

        auto tempStudentai = studentai;
        auto newEnd = remove_if(tempStudentai.begin(), tempStudentai.end(), belowThreshold);

        for (const auto& studentas : studentai) {
            if (studentas.galutinis < 5) {
                paliktukai.push_back(studentas);
            }
        }

        tempStudentai.erase(newEnd, tempStudentai.end());
        pasiektukai = tempStudentai;
    }
    else if (strategija == '3') {

        double threshold = 5;
        auto belowThreshold = [threshold](const Studentas& studentas) {
            return studentas.galutinis < threshold;
        };

        auto aboveThreshold = [threshold](const Studentas& studentas) {
            return studentas.galutinis >= threshold;
        };

        
        remove_copy_if(studentai.begin(), studentai.end(), back_inserter(paliktukai), belowThreshold);

        
        remove_copy_if(studentai.begin(), studentai.end(), back_inserter(pasiektukai), aboveThreshold);
    }

    if (surusiuoti_pagal == '1') {
        sort(pasiektukai.begin(), pasiektukai.end(), palygintiPagalVardaPavarde);
        sort(paliktukai.begin(), paliktukai.end(), palygintiPagalVardaPavarde);
    }
    else if (surusiuoti_pagal == '2') {
        sort(pasiektukai.begin(), pasiektukai.end(), palygintiPagalGalutini);
        sort(paliktukai.begin(), paliktukai.end(), palygintiPagalGalutini);
    }
    else {
        cout << "Neteisingas pasirinkimas, rusiuojama pagal varda ir pavarde.\n";
        sort(pasiektukai.begin(), pasiektukai.end(), palygintiPagalVardaPavarde);
        sort(paliktukai.begin(), paliktukai.end(), palygintiPagalVardaPavarde);
    }

    auto end_time = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::milliseconds>(end_time - start_time);

    start_time = chrono::high_resolution_clock::now();
    for (const auto& studentas : pasiektukai) {
        pasiektukai_failas << studentas.vardas << " " << studentas.pavarde << " " << studentas.galutinis << endl;
    }

    for (const auto& studentas : paliktukai) {
        paliktukai_failas << studentas.vardas << " " << studentas.pavarde << " " << studentas.galutinis << endl;
    }

    paliktukai_failas.close();
    pasiektukai_failas.close();

    end_time = chrono::high_resolution_clock::now();
    auto duration2 = chrono::duration_cast<chrono::milliseconds>(end_time - start_time);

    cout << "Rusiavimo laikas: " << duration.count() << " ms\n";
    cout << "Failu kurimo laikas: " << duration2.count() << " ms\n";
}

int main() {

    vector<Studentas> studentai;
    bool kartoti = true;

    while (kartoti) {

        char konteineriotipas;
        cout << "Pasirinkite konteinerio tipa\n"
            << "1. Vector\n"
            << "2. List\n";
        cin >> konteineriotipas;

        if (konteineriotipas == '1') {
            studentai = vector<Studentas>();
        }
        else {
            list<Studentas> studentai;
        }
        string failo_pavadinimas;
        cout << "Iveskite failo pavadinima: ";
        cin >> failo_pavadinimas;

        ifstream failas(failo_pavadinimas);

        if (!failas.is_open()) {
            cout << "Klaida atidarant faila." << endl;
            return 1;
        }

        auto start_time1 = chrono::high_resolution_clock::now();
        string eilute;
        getline(failas, eilute);

        while (getline(failas, eilute)) {
            istringstream iss(eilute);
            Studentas naujas_studentas;

            iss >> naujas_studentas.vardas >> naujas_studentas.pavarde;

            int balas;
            while (iss >> balas) {
                naujas_studentas.namu_darbai.push_back(balas);
            }

            naujas_studentas.egzaminas = naujas_studentas.namu_darbai.back();
            naujas_studentas.namu_darbai.pop_back();

            naujas_studentas.galutinis = skaiciuotiGalutini(naujas_studentas);

            studentai.push_back(naujas_studentas);
        }

        failas.close();
        auto end_time1 = chrono::high_resolution_clock::now();
        auto duration3 = chrono::duration_cast<chrono::milliseconds>(end_time1 - start_time1);
        cout << "Failo atidarymo laikas: " << duration3.count() << " ms\n";

        // Rūšiuojame studentus pagal galutinį balą
        sort(studentai.begin(), studentai.end(), palygintiPagalGalutini);

        // Sukuriame failus pagal balus
        sukurtiFailusPagalBalus(studentai, failo_pavadinimas, konteineriotipas);

        char kartoti_input;
        cout << "Ar norite kartoti testa? (t/n): ";
        cin >> kartoti_input;

        if (kartoti_input != 't' && kartoti_input != 'T') {
            kartoti = false;
        }
    }

    return 0;
}
